mod create_process_tracking_model;
mod database_operations;
mod database_operations_impl;
mod process_status;
mod update_process_tracking_model;

use crate::errors::*;
use crate::models::common::QueryResults;
use crate::traits::GlyphxDataModel;

use async_trait::async_trait;
use glyphx_core::GlyphxErrorData;
use mongodb::bson::oid::ObjectId;
use mongodb::bson::{doc, from_document, to_bson, DateTime, Document};
use mongodb::options::FindOptions;
use serde::{Deserialize, Serialize};
use serde_json::{json, Value};

use super::common::deserialize_object_id;
pub use create_process_tracking_model::*;
use database_operations::*;
use database_operations_impl::*;
pub use process_status::*;
pub use update_process_tracking_model::*;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ProcessTrackingModel {
    #[serde(rename = "_id", deserialize_with = "deserialize_object_id")]
    pub id: String,
    #[serde(rename = "processId")]
    pub process_id: String,
    #[serde(rename = "processName")]
    pub process_name: String,
    #[serde(rename = "processStatus")]
    pub process_status: ProcessStatus,
    #[serde(rename = "processStartTime")]
    pub process_start_time: DateTime,
    #[serde(rename = "processEndTime", skip_serializing_if = "Option::is_none")]
    pub process_end_time: Option<DateTime>,
    #[serde(rename = "processMessages")]
    pub process_messages: Vec<String>,
    #[serde(rename = "processError")]
    pub process_error: Vec<Value>,
    #[serde(rename = "processResult", skip_serializing_if = "Option::is_none")]
    pub process_result: Option<Value>,
    #[serde(rename = "processHeartbeat", skip_serializing_if = "Option::is_none")]
    pub process_heartbeat: Option<DateTime>,
}

//Functions in this impl block are unique to this collection and must be created by hand.
impl ProcessTrackingModel {
    async fn process_id_exists_impl<T: DatabaseOperations>(
        process_id: &str,
        database_operations: &T,
    ) -> Result<Option<()>, IdExistsError> {
        let raw_document = database_operations
            .count_documents(mongodb::bson::doc! { "processId": process_id }, None)
            .await;
        if raw_document.is_err() {
            return Err(IdExistsError::from_mongo_db_error(
                &raw_document.unwrap_err().kind,
                "process_tracking",
                "process_id_exists",
            ));
        }
        let raw_document = raw_document.unwrap();
        if raw_document == 0 {
            return Ok(None);
        }
        return Ok(Some(()));
    }
    pub async fn process_id_exists(process_id: &str) -> Result<Option<()>, IdExistsError> {
        ProcessTrackingModel::process_id_exists_impl(process_id, &DatabaseOperationsImpl).await
    }

    async fn get_by_process_id_impl<T: DatabaseOperations>(
        process_id: &str,
        database_operations: &T,
    ) -> Result<Option<ProcessTrackingModel>, FindOneError> {
        let filter = doc! { "processId": process_id };
        Self::get_one_by_filter_impl(&filter, database_operations).await
    }

    pub async fn get_by_process_id(
        process_id: &str,
    ) -> Result<Option<ProcessTrackingModel>, FindOneError> {
        ProcessTrackingModel::get_by_process_id_impl(process_id, &DatabaseOperationsImpl).await
    }
}
//Functions here will be auto generated by the glyphx_data_model macro.
impl ProcessTrackingModel {
    async fn get_by_id_impl<T: DatabaseOperations>(
        id: &str,
        database_operation: &T,
    ) -> Result<Option<ProcessTrackingModel>, FindOneError> {
        let oid = ObjectId::parse_str(id);
        if oid.is_err() {
            return Err(FindOneError::InvalidId(GlyphxErrorData::new(
                "The id is not a valid ObjectId".to_string(),
                Some(
                    json!({"collection" : "process_trackings", "operation" : "get_by_id", "id" : id}),
                ),
                None,
            )));
        }
        let oid = oid.unwrap();
        let filter = doc! { "_id": oid };
        Self::get_one_by_filter_impl(&filter, database_operation).await
    }

    async fn get_one_by_filter_impl<T: DatabaseOperations>(
        filter: &Document,
        database_operation: &T,
    ) -> Result<Option<ProcessTrackingModel>, FindOneError> {
        let raw_document = database_operation.find_one(filter.clone(), None).await;
        if raw_document.is_err() {
            return Err(FindOneError::from_mongo_db_error(
                &raw_document.unwrap_err().kind,
                "process_tracking",
                "get_by_id",
            ));
        }

        let raw_document = raw_document.unwrap();
        if raw_document.is_none() {
            return Ok(None);
        }
        Ok(Some(raw_document.unwrap()))
    }
    pub async fn id_exists_impl<T: DatabaseOperations>(
        id: &str,
        database_operation: &T,
    ) -> Result<Option<()>, IdExistsError> {

        let oid = ObjectId::parse_str(id);
        if oid.is_err() {
            return Err(IdExistsError::InvalidId(GlyphxErrorData::new(
                "The id is not a valid ObjectId".to_string(),
                Some(
                    json!({"collection" : "process_trackings", "operation" : "id_exists", "id" : id}),
                ),
                None,
            )));
        }
        let oid = oid.unwrap();
        let filter = doc! { "_id": oid };
        let document_count = database_operation
            .count_documents(filter, None)
            .await;
        if document_count.is_err() {
            return Err(IdExistsError::from_mongo_db_error(
                &document_count.unwrap_err().kind,
                "process_trackings",
                "id_exists",
            ));
        }
        let document_count = document_count.unwrap();
        if document_count == 0 {
            return Ok(None);
        }
        return Ok(Some(()));
    }

    pub async fn all_ids_exist_impl<T: DatabaseOperations>(
        ids: &Vec<&str>,
        database_operation: &T,
    ) -> Result<(), AllIdsExistError> {
        let mut object_ids: Vec<ObjectId> = Vec::new();
        for id in ids {
            let oid = ObjectId::parse_str(id);
            if oid.is_err() {
                return Err(AllIdsExistError::InvalidId(GlyphxErrorData::new(
                    "The id is not a valid ObjectId".to_string(),
                    Some(
                        json!({"collection" : "process_trackings", "operation" : "all_ids_exist", "id" : id}),
                    ),
                    None,
                )));
            }
            object_ids.push(oid.unwrap());
        }
        let filter = doc! { "_id": { "$in": object_ids } };
        let results = database_operation.query_ids(filter, None).await;

        if results.is_err() {
            return Err(AllIdsExistError::from_mongo_db_error(
                &results.unwrap_err().kind,
                "process_trackings",
                "all_ids_exist",
            ));
        }
        let results = results.unwrap();
        if results.is_none() {
            return Err(AllIdsExistError::MissingIds(GlyphxErrorData::new(
                "Unable to find any of the requested ids".to_string(),
                Some(json!({"ids" : ids})),
                None,
            )));
        }
        let mut missing_ids: Vec<&str> = Vec::new();

        let results = results.unwrap();
        for id in ids {
            let mut found = false;
            for result in &results {
                if result.id == *id {
                    found = true;
                    break;
                }
            }
            if !found {
                missing_ids.push(id);
            }
        }
        if missing_ids.len() > 0 {
            return Err(AllIdsExistError::MissingIds(GlyphxErrorData::new(
                "Some Ids Are Missing".to_string(),
                Some(json!({"ids" : missing_ids})),
                None,
            )));
        }
        Ok(())
    }

    pub async fn insert_document_impl<T: DatabaseOperations>(
        input: &CreateProcessTrackingModel,
        database_operations: &T,
    ) -> Result<ProcessTrackingModel, InsertDocumentError> {
        //I don't think that this would ever error since we are using the serializer to create it.
        //So, I am not going to worry about testing it for now.
        let bson = input.to_bson();
        if bson.is_err() {
            let err = bson.err().unwrap();
            let err =
                InsertDocumentError::from_bson_error(err, "process_trackings", "insert_document");
            return Err(err);
        }
        let document = bson.unwrap();

        let insert_results = database_operations.insert_document(document, None).await;

        if insert_results.is_err() {
            let err = insert_results.err().unwrap();
            let err = InsertDocumentError::from_mongo_db_error(
                &err.kind,
                "process_trackings",
                "insert_document",
            );
            return Err(err);
        }

        let insert_results = insert_results.unwrap();

        let id = insert_results.id;
        let get_results = Self::get_by_id_impl(&id, database_operations).await;
        if get_results.is_err() {
            let err = get_results.err().unwrap();
            let err = InsertDocumentError::from_find_one_error(
                &err,
                "process_trackings",
                "insert_document",
            );
            return Err(err);
        }

        let get_results = get_results.unwrap();
        if get_results.is_none() {
            let data = json!({"collection": "process_trackings", "operation": "insert_document"});
            let message = "An unexpected error occurred and the get_by_id operation did not return a document".to_string();
            let error_data = GlyphxErrorData::new(message, Some(data), None);
            return Err(InsertDocumentError::CreateFailure(error_data));
        }

        Ok(get_results.unwrap())
    }

    async fn update_document_by_id_impl<T: DatabaseOperations>(
        id: &str,
        input: &UpdateProcessTrackingModel,
        database_operations: &T,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        let oid = ObjectId::parse_str(id);
        if oid.is_err() {
            return Err(UpdateDocumentError::InvalidId(GlyphxErrorData::new(
                "The id is not a valid ObjectId".to_string(),
                Some(
                    json!({"collection" : "process_trackings", "operation" : "update_document_by_id", "id" : id}),
                ),
                None,
            )));
        }
        let oid = oid.unwrap();
        let filter = doc! { "_id": oid };
        Self::update_document_by_filter_impl(&filter, input, database_operations).await
    }

    async fn update_document_impl<T: DatabaseOperations>(
        filter: &Document,
        document: &Document,
        database_operations: &T,
        operation: &str,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        let update_result = database_operations
            .update_one_document(filter, document, None)
            .await;
        if update_result.is_err() {
            let err = update_result.err().unwrap();
            let err =
                UpdateDocumentError::from_mongo_db_error(&err.kind, "process_trackings", operation);
            return Err(err);
        }

        let update_result = update_result.unwrap();
        if update_result.modified_count == 0 {
            let data = json!({"collection": "process_trackings", "operation": operation});
            let message = "An unexpected error occurred and the update operation did not modify any documents".to_string();
            let error_data = GlyphxErrorData::new(message, Some(data), None);
            return Err(UpdateDocumentError::UpdateFailure(error_data));
        }

        let get_results = Self::get_one_by_filter_impl(filter, database_operations).await;
        if get_results.is_err() {
            let err = get_results.err().unwrap();
            let err =
                UpdateDocumentError::from_find_one_error(&err, "process_trackings", operation);
            return Err(err);
        }

        let get_results = get_results.unwrap();
        if get_results.is_none() {
            let data = json!({"collection": "process_trackings", "operation": operation});
            let message = "An unexpected error occurred and the get_by_id operation did not return a document".to_string();
            let error_data = GlyphxErrorData::new(message, Some(data), None);
            return Err(UpdateDocumentError::UpdateFailure(error_data));
        }

        Ok(get_results.unwrap())
    }

    async fn update_document_by_filter_impl<T: DatabaseOperations>(
        filter: &Document,
        input: &UpdateProcessTrackingModel,
        database_operations: &T,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        if !input.is_valid() {
            return Err(UpdateDocumentError::DocumentValidationFailure(GlyphxErrorData::new(
                "At least one field in the UpdateProcessTrackingModel document must have a value".to_string(),
                Some(json!({"collection" : "process_trackings", "operation" : "update_document_by_filter"})),
                None,
            )));
        }
        let bson = input.to_bson();
        if bson.is_err() {
            let err = bson.err().unwrap();
            let err = UpdateDocumentError::from_bson_error(
                err,
                "process_trackings",
                "update_document_by_filter",
            );
            return Err(err);
        }
        let document = bson.unwrap();

        Self::update_document_impl(
            filter,
            &document,
            database_operations,
            "update_document_by_filter",
        )
        .await
    }

    async fn delete_document_by_id_impl<T: DatabaseOperations>(
        id: &str,
        database_operations: &T,
    ) -> Result<(), DeleteDocumentError> {
        let oid = ObjectId::parse_str(id);
        if oid.is_err() {
            return Err(DeleteDocumentError::InvalidId(GlyphxErrorData::new(
                "The id is not a valid ObjectId".to_string(),
                Some(
                    json!({"collection" : "process_trackings", "operation" : "get_by_id", "id" : id}),
                ),
                None,
            )));
        }
        let oid = oid.unwrap();
        let filter = doc! { "_id": oid };
        Self::delete_document_by_filter_impl(&filter, database_operations).await
    }

    async fn delete_document_by_filter_impl<T: DatabaseOperations>(
        filter: &Document,
        database_operations: &T,
    ) -> Result<(), DeleteDocumentError> {
        let delete_result = database_operations.delete_one_document(filter, None).await;

        if delete_result.is_err() {
            let err = delete_result.err().unwrap();
            let err = DeleteDocumentError::from_mongo_db_error(
                &err.kind,
                "process_trackings",
                "delete_document_by_filter",
            );
            return Err(err);
        }

        let delete_result = delete_result.unwrap();
        if delete_result.deleted_count == 0 {
            let data = json!({"collection": "process_trackings", "operation": "delete_document_by_filter", "filter" : filter});
            let message = "No documents were found which could be deleted".to_string();
            let error_data = GlyphxErrorData::new(message, Some(data), None);
            return Err(DeleteDocumentError::DeleteFailure(error_data));
        }

        Ok(())
    }

    pub async fn add_message_impl<T: DatabaseOperations>(
        id: &str,
        message: &str,
        database_operations: &T,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        let oid = ObjectId::parse_str(id);
        if oid.is_err() {
            return Err(UpdateDocumentError::InvalidId(GlyphxErrorData::new(
                "The id is not a valid ObjectId".to_string(),
                Some(
                    json!({"collection" : "process_trackings", "operation" : "add_message", "id" : id}),
                ),
                None,
            )));
        }
        let oid = oid.unwrap();
        let filter = doc! { "_id": oid };
        Self::add_message_by_filter_impl(&filter, message, database_operations).await
    }

    pub async fn add_message_by_filter_impl<T: DatabaseOperations>(
        filter: &Document,
        message: &str,
        database_operations: &T,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        let operation =
            doc! { "$push": {"processMessages": { "$each": [message], "$position": 0} }};
        Self::update_document_impl(
            filter,
            &operation,
            database_operations,
            "add_message_by_filter",
        )
        .await
    }

    pub async fn add_message(
        id: &str,
        message: &str,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        Self::add_message_impl(id, message, &DatabaseOperationsImpl).await
    }

    pub async fn add_message_by_filter(
        filter: &Document,
        message: &str,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        Self::add_message_by_filter_impl(filter, message, &DatabaseOperationsImpl).await
    }

    pub async fn add_error_impl<T: DatabaseOperations>(
        id: &str,
        error: &Value,
        database_operations: &T,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        let oid = ObjectId::parse_str(id);
        if oid.is_err() {
            return Err(UpdateDocumentError::InvalidId(GlyphxErrorData::new(
                "The id is not a valid ObjectId".to_string(),
                Some(
                    json!({"collection" : "process_trackings", "operation" : "get_by_id", "id" : id}),
                ),
                None,
            )));
        }
        let oid = oid.unwrap();
        let filter = doc! { "_id": oid };
        Self::add_error_by_filter_impl(&filter, error, database_operations).await
    }

    pub async fn add_error_by_filter_impl<T: DatabaseOperations>(
        filter: &Document,
        error: &Value,
        database_operations: &T,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        let error = to_bson(error);
        let error = error.unwrap();
        let operation =
            doc! { "$push": {"processError": { "$each": [error], "$position": 0} }};
        Self::update_document_impl(
            filter,
            &operation,
            database_operations,
            "add_error_by_filter",
        )
        .await
    }

    pub async fn add_error(
        id: &str,
        error: &Value,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        Self::add_error_impl(id, error, &DatabaseOperationsImpl).await
    }

    pub async fn add_error_by_filter(
        filter: &Document,
        error: &Value,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        Self::add_error_by_filter_impl(filter, error, &DatabaseOperationsImpl).await
    }

    async fn query_documents_impl<T: DatabaseOperations>(
        filter: &Document,
        page_number: Option<u64>,
        page_size: Option<u64>,
        database_operations: &T,
    ) -> Result<Option<QueryResults<ProcessTrackingModel>>, QueryDocumentsError> {
        let page_number = page_number.unwrap_or(0);
        let page_size = page_size.unwrap_or(10);

        if page_size == 0 {
            return Err(QueryDocumentsError::InvalidPageSize(GlyphxErrorData::new(
                "The page size must be greater than 0".to_string(),
                Some(
                    json!({"collection" : "process_trackings", "operation" : "query_documents", "page_size" : page_size}),
                ),
                None,
            )));
        }

        let number_of_documents = database_operations
            .count_documents(filter.clone(), None)
            .await;
        if number_of_documents.is_err() {
            return Err(QueryDocumentsError::from_mongo_db_error(
                &number_of_documents.unwrap_err().kind,
                "process_trackings",
                "query_documents",
            ));
        }

        let number_of_documents = number_of_documents.unwrap();
        if number_of_documents == 0 {
            return Ok(None);
        }
        let number_of_pages = number_of_documents.div_ceil(page_size) - 1;
        if page_number > number_of_pages {
            return Err(QueryDocumentsError::InvalidPageNumber(
                GlyphxErrorData::new(
                    "The requested page number is greater than the number of pages".to_string(),
                    Some(
                        json!({"collection" : "process_trackings", "operation" : "query_documents", "number_of_pages" : number_of_pages, "page_number" : page_number}),
                    ),
                    None,
                ),
            ));
        }

        let option_builder = FindOptions::builder()
            .sort(doc! { "processStartTime": -1 })
            .skip(page_number * page_size as u64)
            .limit(page_size as i64);

        let documents = database_operations
            .query_documents(filter.clone(), Some(option_builder.build()))
            .await;
        if documents.is_err() {
            return Err(QueryDocumentsError::from_mongo_db_error(
                &documents.unwrap_err().kind,
                "process_trackings",
                "query_documents",
            ));
        }
        let documents = documents.unwrap();
        if documents.is_none() {
            return Ok(None);
        }

        Ok(Some(QueryResults::<ProcessTrackingModel> {
            results: documents.unwrap(),
            number_of_items: number_of_documents,
            page_number,
            page_size,
        }))
    }
    pub async fn query_documents(
        filter: &Document,
        page_number: Option<u64>,
        page_size: Option<u64>,
    ) -> Result<Option<QueryResults<ProcessTrackingModel>>, QueryDocumentsError> {
        ProcessTrackingModel::query_documents_impl(
            filter,
            page_number,
            page_size,
            &DatabaseOperationsImpl,
        )
        .await
    }
}

#[async_trait]
impl GlyphxDataModel<ProcessTrackingModel, CreateProcessTrackingModel, UpdateProcessTrackingModel>
    for ProcessTrackingModel
{
    fn from_str(value: &str) -> ProcessTrackingModel {
        let parse_result: serde_json::Result<ProcessTrackingModel> = serde_json::from_str(value);
        if parse_result.is_err() {
            panic!(
                "Unable to parse ProcessTrackingModel from string: {}",
                value
            );
        }
        parse_result.unwrap()
    }

    fn from_document(document: &mongodb::bson::Document) -> ProcessTrackingModel {
        let parse_result = from_document(document.to_owned());
        if parse_result.is_err() {
            panic!(
                "Unable to parse ProcessTrackingModel from document: {:?}",
                document
            );
        }
        parse_result.unwrap()
    }

    fn to_json(&self) -> Value {
        let json = serde_json::to_value(&self);
        if json.is_err() {
            panic!(
                "Unable to serialize ProcessTrackingModel to json: {:?}",
                self
            );
        }
        json.unwrap()
    }

    ///When we go to build this in the macro we will need a way to identify ObjectIds that we will
    ///need to convert from Strings to ObjectIds
    fn to_bson(&self) -> Result<Document, mongodb::bson::ser::Error> {
        let bson = to_bson(&self);
        if bson.is_err() {
            return Err(bson.err().unwrap());
        }
        let bson = bson.unwrap();
        let bson = bson.as_document().unwrap();
        let mut document = Document::new();
        bson.keys().for_each(|key| {
            if key == "_id" {
                let str_value = bson.get(key).unwrap().as_str().unwrap();
                let object_id = ObjectId::parse_str(str_value).unwrap();
                document.insert(key, mongodb::bson::Bson::ObjectId(object_id)); 
            } else {
                let v = bson.get(key).unwrap().clone();
                document.insert(key, v);
            }
        });
        
       Ok(document) 
    }

    async fn get_by_id(id: &str) -> Result<Option<ProcessTrackingModel>, FindOneError> {
        ProcessTrackingModel::get_by_id_impl(id, &DatabaseOperationsImpl).await
    }

    async fn get_one_by_filter(
        filter: &Document,
    ) -> Result<Option<ProcessTrackingModel>, FindOneError> {
        ProcessTrackingModel::get_one_by_filter_impl(filter, &DatabaseOperationsImpl).await
    }

    async fn id_exists(id: &str) -> Result<Option<()>, IdExistsError> {
        ProcessTrackingModel::id_exists_impl(id, &DatabaseOperationsImpl).await
    }

    async fn all_ids_exist(ids: &Vec<&str>) -> Result<(), AllIdsExistError> {
        ProcessTrackingModel::all_ids_exist_impl(ids, &DatabaseOperationsImpl).await
    }

    async fn insert_document(
        input: &CreateProcessTrackingModel,
    ) -> Result<ProcessTrackingModel, InsertDocumentError> {
        ProcessTrackingModel::insert_document_impl(input, &DatabaseOperationsImpl).await
    }

    async fn update_document_by_id(
        id: &str,
        input: &UpdateProcessTrackingModel,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        ProcessTrackingModel::update_document_by_id_impl(id, input, &DatabaseOperationsImpl).await
    }
    async fn update_document_by_filter(
        filter: &Document,
        input: &UpdateProcessTrackingModel,
    ) -> Result<ProcessTrackingModel, UpdateDocumentError> {
        ProcessTrackingModel::update_document_by_filter_impl(filter, input, &DatabaseOperationsImpl)
            .await
    }

    async fn delete_document_by_id(id: &str) -> Result<(), DeleteDocumentError> {
        ProcessTrackingModel::delete_document_by_id_impl(id, &DatabaseOperationsImpl).await
    }
    async fn delete_document_by_filter(filter: &Document) -> Result<(), DeleteDocumentError> {
        ProcessTrackingModel::delete_document_by_filter_impl(filter, &DatabaseOperationsImpl).await
    }
}

#[cfg(test)]
mod get_by_id {
    use super::*;
    use mongodb::bson::oid::ObjectId;
    use mongodb::error::{Error as MongoDbError, Result as MongoDbResult};
    #[tokio::test]
    async fn is_ok() {
        let id = ObjectId::new().to_string();
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_find_one()
            .times(1)
            .return_const(MongoDbResult::Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: "process_id".to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: vec!["process_messages".to_string()],
                process_error: vec![Value::Null],
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::get_by_id_impl(&id, &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result.id, "id");
    }

    #[tokio::test]
    async fn is_none() {
        let id = ObjectId::new().to_string();
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_find_one()
            .times(1)
            .return_const(MongoDbResult::Ok(None));

        let result = ProcessTrackingModel::get_by_id_impl(&id, &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn is_error() {
        let id = ObjectId::new().to_string();
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_find_one()
            .times(1)
            .return_const(MongoDbResult::Err(MongoDbError::custom(
                "An error occurred",
            )));

        let result = ProcessTrackingModel::get_by_id_impl(&id, &mock_impl).await;
        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            FindOneError::UnexpectedError(error_data) => {
                let operation = error_data.data.unwrap();
                let operation = operation["operation"].as_str().unwrap();
                assert_eq!(operation, "get_by_id");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod get_one_by_filter {
    use super::*;
    use mongodb::error::{Error as MongoDbError, Result as MongoDbResult};

    #[tokio::test]
    async fn is_ok() {
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_find_one()
            .times(1)
            .return_const(MongoDbResult::Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: "process_id".to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: vec!["process_messages".to_string()],
                process_error: vec![Value::Null],
                process_result: None,
                process_heartbeat: None,
            })));

        let result =
            ProcessTrackingModel::get_one_by_filter_impl(&doc! {"_id": "id"}, &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result.id, "id");
    }

    #[tokio::test]
    async fn is_none() {
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_find_one()
            .times(1)
            .return_const(MongoDbResult::Ok(None));

        let result =
            ProcessTrackingModel::get_one_by_filter_impl(&doc! { "_id" : "id"}, &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn is_error() {
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_find_one()
            .times(1)
            .return_const(MongoDbResult::Err(MongoDbError::custom(
                "An error occurred",
            )));

        let result =
            ProcessTrackingModel::get_one_by_filter_impl(&doc! { "_id" : "id" }, &mock_impl).await;
        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            FindOneError::UnexpectedError(error_data) => {
                let operation = error_data.data.unwrap();
                let operation = operation["operation"].as_str().unwrap();
                assert_eq!(operation, "get_by_id");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod get_by_process_id {
    use super::*;
    use mongodb::error::{Error as MongoDbError, Result as MongoDbResult};

    #[tokio::test]
    async fn is_ok() {
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_find_one()
            .once()
            .withf(|filter, _| {
                let json_str = filter.to_string();
                let json_value: serde_json::Value = serde_json::from_str(&json_str).unwrap();
                let process_id = json_value["processId"].as_str().unwrap();
                process_id == "process_id"
            })
            .return_const(MongoDbResult::Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: "process_id".to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: vec!["process_messages".to_string()],
                process_error: vec![Value::Null],
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::get_by_process_id_impl("process_id", &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result.id, "id");
    }
}

#[cfg(test)]
mod id_exists {
    use super::*;
    use mongodb::error::{Error as MongoDbError, Result as MongoDbResult};

    #[tokio::test]
    async fn id_exists() {
        let id = ObjectId::new().to_string();
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .times(1)
            .return_const(Ok(1));

        let result = ProcessTrackingModel::id_exists_impl(&id, &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_some());
    }

    #[tokio::test]
    async fn id_does_not_exist() {
        let id = ObjectId::new().to_string();
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .times(1)
            .return_const(MongoDbResult::Ok(0));

        let result = ProcessTrackingModel::id_exists_impl(&id, &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn is_error() {
        let id = ObjectId::new().to_string();
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .times(1)
            .return_const(MongoDbResult::Err(MongoDbError::custom(
                "An error occurred",
            )));

        let result = ProcessTrackingModel::id_exists_impl(&id, &mock_impl).await;
        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            IdExistsError::UnexpectedError(error_data) => {
                let operation = error_data.data.unwrap();
                let operation = operation["operation"].as_str().unwrap();
                assert_eq!(operation, "id_exists");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn invalid_oid() {

        let id = "invalid".to_string();
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .never()
            .return_const(MongoDbResult::Err(MongoDbError::custom(
                "An error occurred",
            )));

        let result = ProcessTrackingModel::id_exists_impl(&id, &mock_impl).await;
        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            IdExistsError::InvalidId(error_data) => {
                let operation = error_data.data.unwrap();
                let operation = operation["operation"].as_str().unwrap();
                assert_eq!(operation, "id_exists");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod process_id_exists {
    use super::*;
    use mongodb::error::{Error as MongoDbError, Result as MongoDbResult};

    #[tokio::test]
    async fn process_id_exists() {
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .times(1)
            .withf(|filter, _| {
                let json_str = filter.to_string();
                let json_value: serde_json::Value = serde_json::from_str(&json_str).unwrap();
                let process_id = json_value["processId"].as_str().unwrap();
                process_id == "process_id"
            })
            .return_const(Ok(1));

        let result = ProcessTrackingModel::process_id_exists_impl("process_id", &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_some());
    }

    #[tokio::test]
    async fn id_does_not_exist() {
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .times(1)
            .withf(|filter, _| {
                let json_str = filter.to_string();
                let json_value: serde_json::Value = serde_json::from_str(&json_str).unwrap();
                let process_id = json_value["processId"].as_str().unwrap();
                process_id == "process_id"
            })
            .return_const(Ok(0));

        let result = ProcessTrackingModel::process_id_exists_impl("process_id", &mock_impl).await;
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.is_none());
    }

    #[tokio::test]
    async fn is_error() {
        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .times(1)
            .withf(|filter, _| {
                let json_str = filter.to_string();
                let json_value: serde_json::Value = serde_json::from_str(&json_str).unwrap();
                let process_id = json_value["processId"].as_str().unwrap();
                process_id == "process_id"
            })
            .return_const(MongoDbResult::Err(MongoDbError::custom(
                "An error occurred",
            )));

        let result = ProcessTrackingModel::process_id_exists_impl("process_id", &mock_impl).await;
        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            IdExistsError::UnexpectedError(error_data) => {
                let operation = error_data.data.unwrap();
                let operation = operation["operation"].as_str().unwrap();
                assert_eq!(operation, "process_id_exists");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod process_tracking_model_tests {
    use super::*;

    #[test]
    fn test1() {
        let id1 = ObjectId::new().to_string();
        let id2 = ObjectId::new().to_string();
        let model = ProcessTrackingModel {
            id: id1.clone(),
            process_id: "process_id".to_string(),
            process_name: "process_name".to_string(),
            process_status: ProcessStatus::Running,
            process_start_time: DateTime::now(),
            process_end_time: None,
            process_messages: vec!["process_messages".to_string()],
            process_error: vec![Value::Null],
            process_result: None,
            process_heartbeat: None,
        };

        let output = model.to_bson().unwrap();
        let json = model.to_json();
        assert!(true);

        let document = output.clone();
        let s  = from_document::<ProcessTrackingModel>(document.clone());
        let _s = s.unwrap();
        assert!(true);

        let json2 = serde_json::json!({
            "_id": id2.clone(),
            "process_id": "process_id",
            "process_name": "process_name",
            "process_status": "Bad",
            "process_start_time": "2023-11-03 17:47:16.641 +00:00:00",
            "process_end_time": null,
            "process_messages": [
                "process_messages"
            ],
            "process_error": [
                null
            ],
            "process_result": null,
            "process_heartbeat": null
        });
        let s2: serde_json::Result<ProcessTrackingModel> = serde_json::from_value(json2);
        let err = s2.unwrap_err();
        let _err_msg = format!("{:?}", err);
        let _cat = format!("{:?}", err.classify());
        assert!(true);
    }
}

#[cfg(test)]
mod all_ids_exist {
    use super::*;
    use crate::models::common::*;
    use mongodb::error::{Error as MongoDbError, Result as MongoDbResult};

    #[tokio::test]
    async fn all_ids_exist() {
        let id1 = ObjectId::new().to_string();
        let id2 = ObjectId::new().to_string();
        let id3 = ObjectId::new().to_string();
        let ids = vec![id1.as_str(), &id2.as_str(), &id3.as_str()];

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_query_ids()
            .times(1)
            .return_const(MongoDbResult::Ok(Some(vec![
                DocumentIds {
                    id: id1.clone(),
                },
                DocumentIds {
                    id: id2.clone(),
                },
                DocumentIds {
                    id: id3.clone(),
                },
            ])));

        let result = ProcessTrackingModel::all_ids_exist_impl(&ids, &mock_impl).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn some_ids_exist() {
        let id1 = ObjectId::new().to_string();
        let id2 = ObjectId::new().to_string();
        let id3 = ObjectId::new().to_string();
        let ids = vec![id1.as_str(), &id2.as_str(), &id3.as_str()];


        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_query_ids()
            .times(1)
            .return_const(MongoDbResult::Ok(Some(vec![DocumentIds {
                id: id2.clone(),
            }])));

        let result = ProcessTrackingModel::all_ids_exist_impl(&ids, &mock_impl).await;
        assert!(result.is_err());
        match result.err().unwrap() {
            AllIdsExistError::MissingIds(error_data) => {
                let ids = error_data.data.unwrap();
                let ids = ids["ids"].as_array().unwrap();
                assert_eq!(ids.len(), 2);
                assert_eq!(ids[0], id1);
                assert_eq!(ids[1], id3);
            }
            _ => panic!("Unexpected error type"),
        }
    }
    #[tokio::test]
    async fn no_ids_exist() {
        let id1 = ObjectId::new().to_string();
        let id2 = ObjectId::new().to_string();
        let id3 = ObjectId::new().to_string();
        let ids = vec![id1.as_str(), &id2.as_str(), &id3.as_str()];


        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_query_ids()
            .times(1)
            .return_const(MongoDbResult::Ok(None));

        let result = ProcessTrackingModel::all_ids_exist_impl(&ids, &mock_impl).await;
        assert!(result.is_err());
        match result.err().unwrap() {
            AllIdsExistError::MissingIds(error_data) => {
                let ids = error_data.data.unwrap();
                let ids = ids["ids"].as_array().unwrap();
                assert_eq!(ids.len(), 3);
                assert_eq!(ids[0], id1);
                assert_eq!(ids[1], id2);
                assert_eq!(ids[2], id3);
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn mongodb_error() {
        let id1 = ObjectId::new().to_string();
        let id2 = ObjectId::new().to_string();
        let id3 = ObjectId::new().to_string();
        let ids = vec![id1.as_str(), &id2.as_str(), &id3.as_str()];


        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_query_ids()
            .times(1)
            .return_const(MongoDbResult::Err(MongoDbError::custom(
                "An error occurred",
            )));

        let result = ProcessTrackingModel::all_ids_exist_impl(&ids, &mock_impl).await;
        assert!(result.is_err());
        match result.err().unwrap() {
            AllIdsExistError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "all_ids_exist");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod insert_document {
    use super::*;
    use crate::models::common::*;
    use mongodb::error::Error as MongoDbError;

    #[tokio::test]
    async fn is_ok() {
        let id = mongodb::bson::oid::ObjectId::new();
        let process_id = "process_id";
        let process_name = "test process";
        let insert_document = CreateProcessTrackingModelBuilder::default()
            .process_id(process_id.to_string())
            .process_name(process_name.to_string())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_insert_document()
            .once()
            .return_const(Ok(CreateOneData { id: id.to_string() }));

        mocks
            .expect_find_one()
            .once()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: id.to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::insert_document_impl(&insert_document, &mocks).await;

        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.id, id.to_string());
        assert_eq!(result.process_id, process_id);
        assert_eq!(result.process_name, process_name);
    }

    #[tokio::test]
    async fn call_to_insert_document_fails() {
        let id = mongodb::bson::oid::ObjectId::new();
        let process_id = "process_id";
        let process_name = "test process";
        let insert_document = CreateProcessTrackingModelBuilder::default()
            .process_id(process_id.to_string())
            .process_name(process_name.to_string())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_insert_document()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        mocks
            .expect_find_one()
            .never()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: id.to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::insert_document_impl(&insert_document, &mocks).await;

        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            InsertDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "insert_document");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn get_by_id_fails() {
        let id = mongodb::bson::oid::ObjectId::new();
        let process_id = "process_id";
        let process_name = "test process";
        let insert_document = CreateProcessTrackingModelBuilder::default()
            .process_id(process_id.to_string())
            .process_name(process_name.to_string())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_insert_document()
            .once()
            .return_const(Ok(CreateOneData { id: id.to_string() }));

        mocks
            .expect_find_one()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        let result = ProcessTrackingModel::insert_document_impl(&insert_document, &mocks).await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            InsertDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "insert_document");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn get_by_id_returns_none() {
        let id = mongodb::bson::oid::ObjectId::new();
        let process_id = "process_id";
        let process_name = "test process";
        let insert_document = CreateProcessTrackingModelBuilder::default()
            .process_id(process_id.to_string())
            .process_name(process_name.to_string())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_insert_document()
            .once()
            .return_const(Ok(CreateOneData { id: id.to_string() }));

        mocks.expect_find_one().once().return_const(Ok(None));

        let result = ProcessTrackingModel::insert_document_impl(&insert_document, &mocks).await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            InsertDocumentError::CreateFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "insert_document");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod update_document_by_id {
    use super::*;
    use crate::models::common::*;

    #[tokio::test]
    async fn is_ok() {
        let id = mongodb::bson::oid::ObjectId::new();
        let process_id = "process_id";
        let process_name = "test process";
        let update_document = UpdateProcessTrackingModelBuilder::default()
            .process_end_time(DateTime::now())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mocks
            .expect_find_one()
            .once()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: id.to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::update_document_by_id_impl(
            &id.to_string(),
            &update_document,
            &mocks,
        )
        .await;

        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.id, id.to_string());
        assert_eq!(result.process_id, process_id);
        assert_eq!(result.process_name, process_name);
    }
}

#[cfg(test)]
mod update_document_by_filter {
    use super::*;
    use crate::models::common::*;
    use mongodb::error::Error as MongoDbError;

    #[tokio::test]
    async fn is_ok() {
        let id = mongodb::bson::oid::ObjectId::new();
        let process_id = "process_id";
        let process_name = "test process";
        let update_document = UpdateProcessTrackingModelBuilder::default()
            .process_end_time(DateTime::now())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mocks
            .expect_find_one()
            .once()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: id.to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::update_document_by_filter_impl(
            &doc! { "_id": id.to_string()},
            &update_document,
            &mocks,
        )
        .await;

        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.id, id.to_string());
        assert_eq!(result.process_id, process_id);
        assert_eq!(result.process_name, process_name);
    }

    #[tokio::test]
    async fn call_to_update_document_fails() {
        let id = mongodb::bson::oid::ObjectId::new();
        let process_id = "process_id";
        let process_name = "test process";
        let update_document = UpdateProcessTrackingModelBuilder::default()
            .process_end_time(DateTime::now())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_update_one_document()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        mocks
            .expect_find_one()
            .never()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: id.to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::update_document_by_filter_impl(
            &doc! { "_id" : id.to_string()},
            &update_document,
            &mocks,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            UpdateDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "update_document_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn get_by_filter_fails() {
        let id = mongodb::bson::oid::ObjectId::new();
        let update_document = UpdateProcessTrackingModelBuilder::default()
            .process_end_time(DateTime::now())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_update_one_document()
            .once()
            .return_const(UpdateOneResult::Ok(UpdateOneData { modified_count: 1 }));

        mocks
            .expect_find_one()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        let result = ProcessTrackingModel::update_document_by_filter_impl(
            &doc! { "_id" : id.to_string()},
            &update_document,
            &mocks,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "update_document_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn get_by_filter_returns_none() {
        let id = mongodb::bson::oid::ObjectId::new();
        let insert_document = UpdateProcessTrackingModelBuilder::default()
            .process_end_time(DateTime::now())
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mocks.expect_find_one().once().return_const(Ok(None));

        let result = ProcessTrackingModel::update_document_by_filter_impl(
            &doc! { "id" : id.to_string()},
            &insert_document,
            &mocks,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UpdateFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "update_document_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn validation_fails() {
        let id = mongodb::bson::oid::ObjectId::new();
        let insert_document = UpdateProcessTrackingModelBuilder::default()
            .build()
            .unwrap();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_update_one_document()
            .never()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mocks.expect_find_one().never().return_const(Ok(None));

        let result = ProcessTrackingModel::update_document_by_filter_impl(
            &doc! { "id" : id.to_string()},
            &insert_document,
            &mocks,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::DocumentValidationFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "update_document_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod delete_document_by_id {
    use super::*;
    use crate::models::common::*;

    #[tokio::test]
    async fn is_ok() {
        let id = mongodb::bson::oid::ObjectId::new();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_delete_one_document()
            .once()
            .return_const(Ok(DeleteOneData { deleted_count: 1 }));

        let result =
            ProcessTrackingModel::delete_document_by_id_impl(&id.to_string(), &mocks).await;

        assert!(result.is_ok());
    }
}

#[cfg(test)]
mod delete_document_by_filter {
    use super::*;
    use crate::models::common::*;
    use mongodb::error::Error as MongoDbError;

    #[tokio::test]
    async fn is_ok() {
        let id = mongodb::bson::oid::ObjectId::new();
        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_delete_one_document()
            .once()
            .return_const(Ok(DeleteOneData { deleted_count: 1 }));

        let result = ProcessTrackingModel::delete_document_by_filter_impl(
            &doc! { "_id": id.to_string()},
            &mocks,
        )
        .await;

        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn call_to_delete_document_fails() {
        let id = mongodb::bson::oid::ObjectId::new();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_delete_one_document()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        let result = ProcessTrackingModel::delete_document_by_filter_impl(
            &doc! { "_id" : id.to_string()},
            &mocks,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();
        match result {
            DeleteDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "delete_document_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn no_documents_deleted() {
        let id = mongodb::bson::oid::ObjectId::new();

        let mut mocks = MockDatabaseOperations::new();
        mocks
            .expect_delete_one_document()
            .once()
            .return_const(Ok(DeleteOneData { deleted_count: 0 }));

        let result = ProcessTrackingModel::delete_document_by_filter_impl(
            &doc! { "id" : id.to_string()},
            &mocks,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            DeleteDocumentError::DeleteFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "delete_document_by_filter");
                assert_eq!(data["collection"], "process_trackings");
                assert!(data["filter"].is_object());
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod add_message_by_filter {
    use super::*;
    use crate::models::common::*;
    use mongodb::error::Error as MongoDbError;

    #[tokio::test]
    async fn is_ok() {
        let process_id = "process_id";

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl
            .expect_find_one()
            .once()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::add_message_by_filter_impl(
            &doc! { "processId": process_id},
            "message",
            &mock_impl,
        )
        .await;

        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn update_errors() {
        let process_id = "process_id";

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        mock_impl
            .expect_find_one()
            .never()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::add_message_by_filter_impl(
            &doc! { "processId": process_id},
            "message",
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_message_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn no_documents_updated() {
        let process_id = "process_id";

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 0 }));

        mock_impl
            .expect_find_one()
            .never()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::add_message_by_filter_impl(
            &doc! { "processId": process_id},
            "message",
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UpdateFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_message_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn find_document_errors() {
        let process_id = "process_id";

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl
            .expect_find_one()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        let result = ProcessTrackingModel::add_message_by_filter_impl(
            &doc! { "processId": process_id},
            "message",
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_message_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn find_document_returns_none() {
        let process_id = "process_id";

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl.expect_find_one().once().return_const(Ok(None));

        let result = ProcessTrackingModel::add_message_by_filter_impl(
            &doc! { "processId": process_id},
            "message",
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UpdateFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_message_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod add_message_by_id {
    use super::*;
    use crate::models::common::*;

    #[tokio::test]
    async fn is_ok() {
        let id = ObjectId::new().to_string();

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl
            .expect_find_one()
            .once()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: id.clone(),
                process_id: "process_id".to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result =
            ProcessTrackingModel::add_message_impl(&id, "message", &mock_impl).await;

        assert!(result.is_ok());
    }
}

#[cfg(test)]
mod add_error_by_filter {
    use super::*;
    use crate::models::common::*;
    use mongodb::error::Error as MongoDbError;

    #[tokio::test]
    async fn is_ok() {
        let process_id = "process_id";
        let error = json!({"error": "error"});
        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl
            .expect_find_one()
            .once()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: vec![error.clone()],
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::add_error_by_filter_impl(
            &doc! { "processId": process_id},
            &error,
            &mock_impl,
        )
        .await;

        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn update_errors() {
        let process_id = "process_id";
        let error = json!({"error": "error"});

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        mock_impl
            .expect_find_one()
            .never()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: vec![error.clone()],
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::add_error_by_filter_impl(
            &doc! { "processId": process_id},
            &error,
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_error_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn no_documents_updated() {
        let process_id = "process_id";
        let error = json!({"error": "error"});

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 0 }));

        mock_impl
            .expect_find_one()
            .never()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: vec![error.clone()],
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::add_error_by_filter_impl(
            &doc! { "processId": process_id},
            &error,
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UpdateFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_error_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn find_document_errors() {
        let process_id = "process_id";
        let error = json!({"error": "error"});

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl
            .expect_find_one()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        let result = ProcessTrackingModel::add_error_by_filter_impl(
            &doc! { "processId": process_id},
            &error,
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_error_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn find_document_returns_none() {
        let process_id = "process_id";
        let error = json!({"error": "error"});

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl.expect_find_one().once().return_const(Ok(None));

        let result = ProcessTrackingModel::add_error_by_filter_impl(
            &doc! { "processId": process_id},
            &error,
            &mock_impl,
        )
        .await;

        assert!(result.is_err());
        let result = result.err().unwrap();

        match result {
            UpdateDocumentError::UpdateFailure(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "add_error_by_filter");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }
}

#[cfg(test)]
mod add_error_by_id {
    use super::*;
    use crate::models::common::*;

    #[tokio::test]
    async fn is_ok() {
        let id = ObjectId::new().to_string();
        let process_id = "process_id";
        let error = json!({"error": "error"});

        let mut mock_impl = MockDatabaseOperations::new();

        mock_impl
            .expect_update_one_document()
            .once()
            .return_const(Ok(UpdateOneData { modified_count: 1 }));

        mock_impl
            .expect_find_one()
            .once()
            .return_const(Ok(Some(ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: "process_name".to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            })));

        let result = ProcessTrackingModel::add_error_impl(&id, &error, &mock_impl).await;

        assert!(result.is_ok());
    }
}

#[cfg(test)]
mod query_documents {
    use super::*;
    use crate::models::common::*;
    use mongodb::error::Error as MongoDbError;

    #[tokio::test]
    async fn is_ok() {
        let process_id = "process_id";
        let process_name = "process_name";

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .once()
            .return_const(Ok(1));

        mock_impl
            .expect_query_documents()
            .once()
            .return_const(Ok(Some(vec![ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            }])));

        let results =
            ProcessTrackingModel::query_documents_impl(&doc! {"_id": "id"}, None, None, &mock_impl)
                .await;

        assert!(results.is_ok());
        let results = results.unwrap();
        assert!(results.is_some());
        let results = results.unwrap();
        assert_eq!(results.number_of_items, 1);
        assert_eq!(results.results.len(), 1);
        assert_eq!(results.page_number, 0);
        assert_eq!(results.page_size, 10);
    }

    #[tokio::test]
    async fn is_ok_no_defaults() {
        let process_id = "process_id";
        let process_name = "process_name";
        let page_size = 5;
        let page_number = 1;

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .once()
            .return_const(Ok(6));

        mock_impl
            .expect_query_documents()
            .once()
            .return_const(Ok(Some(vec![ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            }])));

        let results = ProcessTrackingModel::query_documents_impl(
            &doc! {"_id": "id"},
            Some(page_number),
            Some(page_size),
            &mock_impl,
        )
        .await;

        assert!(results.is_ok());
        let results = results.unwrap();
        assert!(results.is_some());
        let results = results.unwrap();
        assert_eq!(results.number_of_items, 6);
        assert_eq!(results.results.len(), 1);
        assert_eq!(results.page_number, page_number);
        assert_eq!(results.page_size, page_size);
    }

    #[tokio::test]
    async fn page_size_is_0() {
        let process_id = "process_id";
        let process_name = "process_name";
        let page_size = 0;
        let page_number = 1;

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .never()
            .return_const(Ok(6));

        mock_impl
            .expect_query_documents()
            .never()
            .return_const(Ok(Some(vec![ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            }])));

        let results = ProcessTrackingModel::query_documents_impl(
            &doc! {"_id": "id"},
            Some(page_number),
            Some(page_size),
            &mock_impl,
        )
        .await;

        assert!(results.is_err());
        let results = results.err().unwrap();
        match results {
            QueryDocumentsError::InvalidPageSize(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "query_documents");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn count_documents_errors() {
        let process_id = "process_id";
        let process_name = "process_name";
        let page_size = 5;
        let page_number = 1;

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        mock_impl
            .expect_query_documents()
            .never()
            .return_const(Ok(Some(vec![ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            }])));

        let results = ProcessTrackingModel::query_documents_impl(
            &doc! {"_id": "id"},
            Some(page_number),
            Some(page_size),
            &mock_impl,
        )
        .await;

        assert!(results.is_err());
        let results = results.err().unwrap();
        match results {
            QueryDocumentsError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "query_documents");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn number_of_documents_is_zero() {
        let process_id = "process_id";
        let process_name = "process_name";
        let page_size = 5;
        let page_number = 1;

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .once()
            .return_const(Ok(0));

        mock_impl
            .expect_query_documents()
            .never()
            .return_const(Ok(Some(vec![ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            }])));

        let results = ProcessTrackingModel::query_documents_impl(
            &doc! {"_id": "id"},
            Some(page_number),
            Some(page_size),
            &mock_impl,
        )
        .await;

        assert!(results.is_ok());
        let results = results.unwrap();
        assert!(results.is_none());
    }

    #[tokio::test]
    async fn invalid_page_number() {
        let process_id = "process_id";
        let process_name = "process_name";
        let page_size = 5;
        let page_number = 1;

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .once()
            .return_const(Ok(4));

        mock_impl
            .expect_query_documents()
            .never()
            .return_const(Ok(Some(vec![ProcessTrackingModel {
                id: "id".to_string(),
                process_id: process_id.to_string(),
                process_name: process_name.to_string(),
                process_status: ProcessStatus::Running,
                process_start_time: DateTime::now(),
                process_end_time: None,
                process_messages: Vec::new(),
                process_error: Vec::new(),
                process_result: None,
                process_heartbeat: None,
            }])));

        let results = ProcessTrackingModel::query_documents_impl(
            &doc! {"_id": "id"},
            Some(page_number),
            Some(page_size),
            &mock_impl,
        )
        .await;

        assert!(results.is_err());
        let results = results.err().unwrap();
        match results {
            QueryDocumentsError::InvalidPageNumber(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "query_documents");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn query_documents_is_error() {
        let process_id = "process_id";
        let process_name = "process_name";
        let page_size = 5;
        let page_number = 1;

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .once()
            .return_const(Ok(6));

        mock_impl
            .expect_query_documents()
            .once()
            .return_const(Err(MongoDbError::custom("An error occurred")));

        let results = ProcessTrackingModel::query_documents_impl(
            &doc! {"_id": "id"},
            Some(page_number),
            Some(page_size),
            &mock_impl,
        )
        .await;

        assert!(results.is_err());
        let results = results.err().unwrap();
        match results {
            QueryDocumentsError::UnexpectedError(error_data) => {
                let data = error_data.data.unwrap();
                assert_eq!(data["operation"], "query_documents");
                assert_eq!(data["collection"], "process_trackings");
            }
            _ => panic!("Unexpected error type"),
        }
    }

    #[tokio::test]
    async fn query_documents_is_none() {
        let process_id = "process_id";
        let process_name = "process_name";
        let page_size = 5;
        let page_number = 1;

        let mut mock_impl = MockDatabaseOperations::new();
        mock_impl
            .expect_count_documents()
            .once()
            .return_const(Ok(6));

        mock_impl
            .expect_query_documents()
            .once()
            .return_const(Ok(None));

        let results = ProcessTrackingModel::query_documents_impl(
            &doc! {"_id": "id"},
            Some(page_number),
            Some(page_size),
            &mock_impl,
        )
        .await;

        assert!(results.is_ok());
        let results = results.unwrap();
        assert!(results.is_none());
    }
}
