// THIS CODE WAS AUTOMATICALLY GENERATED
import {assert} from 'chai';
import {{{pascalcase this.name}}Model} from '../../..//mongoose/models/{{camelcase this.name}}';
import {WorkspaceModel} from '../../../mongoose/models/workspace';
import {UserModel} from '../../../mongoose/models/user';
import {{{pascalcase this.name}}TemplateModel} from '../../../mongoose/models/{{camelcase this.name}}Template';
import {StateModel} from '../../../mongoose/models/state';
import {MemberModel} from '../../../mongoose/models/member';

import {database, database as databaseTypes} from '@glyphx/types';
import {error} from '@glyphx/core';
import mongoose from 'mongoose';
import {createSandbox} from 'sinon';
import {TagModel} from '../../../mongoose/models';

describe('#mongoose/models/{{camelcase this.name}}', () => {
  context('{{camelcase this.name}}IdExists', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('should return true if the {{camelcase this.name}}Id exists', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const findByIdStub = sandbox.stub();
      findByIdStub.resolves({_id: {{camelcase this.name}}Id});
      sandbox.replace({{pascalcase this.name}}Model, 'findById', findByIdStub);

      const result = await {{pascalcase this.name}}Model.{{camelcase this.name}}IdExists({{camelcase this.name}}Id);

      assert.isTrue(result);
    });

    it('should return false if the {{camelcase this.name}}Id does not exist', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const findByIdStub = sandbox.stub();
      findByIdStub.resolves(null);
      sandbox.replace({{pascalcase this.name}}Model, 'findById', findByIdStub);

      const result = await {{pascalcase this.name}}Model.{{camelcase this.name}}IdExists({{camelcase this.name}}Id);

      assert.isFalse(result);
    });

    it('will throw a DatabaseOperationError when the underlying database connection errors', async () => {
      const userId = new mongoose.Types.ObjectId();
      const findByIdStub = sandbox.stub();
      findByIdStub.rejects('something unexpected has happend');
      sandbox.replace({{pascalcase this.name}}Model, 'findById', findByIdStub);

      let errorred = false;
      try {
        await {{pascalcase this.name}}Model.{{camelcase this.name}}IdExists(userId);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errorred = true;
      }
      assert.isTrue(errorred);
    });
  });

  context('create{{pascalcase this.name}}', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will create a {{camelcase this.name}} document', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateWorkspace',
        sandbox.stub().resolves(MOCK_PROJECT.workspace._id)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateMembers',
        sandbox.stub().resolves(MOCK_PROJECT.members)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateTags',
        sandbox.stub().resolves(MOCK_PROJECT.tags)
      );

      const objectId = new mongoose.Types.ObjectId();
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'create',
        sandbox.stub().resolves([{_id: objectId}])
      );
      sandbox.replace({{pascalcase this.name}}Model, 'validate', sandbox.stub().resolves(true));
      const stub = sandbox.stub();
      stub.resolves({_id: objectId});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', stub);
      const {{camelcase this.name}}Document = await {{pascalcase this.name}}Model.create{{pascalcase this.name}}(MOCK_PROJECT);

      assert.strictEqual({{camelcase this.name}}Document._id, objectId);
      assert.isTrue(stub.calledOnce);
    });

    it('will create a {{camelcase this.name}} document with nullish coalesce', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateWorkspace',
        sandbox.stub().resolves(MOCK_PROJECT.workspace._id)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateMembers',
        sandbox.stub().resolves(MOCK_PROJECT.members)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateTags',
        sandbox.stub().resolves(MOCK_PROJECT.tags)
      );

      const objectId = new mongoose.Types.ObjectId();
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'create',
        sandbox
          .stub()
          .resolves([
            {_id: objectId, description: ' ', viewName: ' ', files: []},
          ])
      );
      sandbox.replace({{pascalcase this.name}}Model, 'validate', sandbox.stub().resolves(true));
      const stub = sandbox.stub();
      stub.resolves({
        _id: objectId,
        description: ' ',
        viewName: ' ',
        files: [],
      });
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', stub);
      const {{camelcase this.name}}Document = await {{pascalcase this.name}}Model.create{{pascalcase this.name}}(
        MOCK_NULLISH_PROJECT
      );
      assert.strictEqual({{camelcase this.name}}Document.files.length, 0);
      assert.strictEqual({{camelcase this.name}}Document.description, ' ');
      assert.strictEqual({{camelcase this.name}}Document.viewName, ' ');
      assert.strictEqual({{camelcase this.name}}Document._id, objectId);
      assert.isTrue(stub.calledOnce);
    });

    it('will rethrow a DataValidationError when a validator throws one', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateWorkspace',
        sandbox
          .stub()
          .rejects(
            new error.DataValidationError(
              'The worksapce does not exist',
              '{{camelcase this.name}}',
              {}
            )
          )
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateMembers',
        sandbox.stub().resolves(MOCK_PROJECT.members)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateTags',
        sandbox.stub().resolves(MOCK_PROJECT.tags)
      );

      const objectId = new mongoose.Types.ObjectId();
      sandbox.replace({{pascalcase this.name}}Model, 'validate', sandbox.stub().resolves(true));
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'create',
        sandbox.stub().resolves([{_id: objectId}])
      );
      const stub = sandbox.stub();
      stub.resolves({_id: objectId});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', stub);
      let hasError = false;
      try {
        await {{pascalcase this.name}}Model.create{{pascalcase this.name}}(MOCK_PROJECT);
      } catch (err) {
        assert.instanceOf(err, error.DataValidationError);
        hasError = true;
      }
      assert.isTrue(hasError);
    });

    it('will throw a DatabaseOperationError when an underlying model function errors', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateWorkspace',
        sandbox.stub().resolves(MOCK_PROJECT.workspace._id)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateMembers',
        sandbox.stub().resolves(MOCK_PROJECT.members)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateTags',
        sandbox.stub().resolves(MOCK_PROJECT.tags)
      );

      const objectId = new mongoose.Types.ObjectId();
      sandbox.replace({{pascalcase this.name}}Model, 'validate', sandbox.stub().resolves(true));
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'create',
        sandbox.stub().rejects('oops, something bad has happened')
      );
      const stub = sandbox.stub();
      stub.resolves({_id: objectId});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', stub);
      let hasError = false;
      try {
        await {{pascalcase this.name}}Model.create{{pascalcase this.name}}(MOCK_PROJECT);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        hasError = true;
      }
      assert.isTrue(hasError);
    });

    it('will throw an Unexpected Error when create does not return an object with an _id', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateWorkspace',
        sandbox.stub().resolves(MOCK_PROJECT.workspace._id)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateMembers',
        sandbox.stub().resolves(MOCK_PROJECT.members)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateTags',
        sandbox.stub().resolves(MOCK_PROJECT.tags)
      );

      const objectId = new mongoose.Types.ObjectId();
      sandbox.replace({{pascalcase this.name}}Model, 'validate', sandbox.stub().resolves(true));
      sandbox.replace({{pascalcase this.name}}Model, 'create', sandbox.stub().resolves([{}]));
      const stub = sandbox.stub();
      stub.resolves({_id: objectId});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', stub);
      let hasError = false;
      try {
        await {{pascalcase this.name}}Model.create{{pascalcase this.name}}(MOCK_PROJECT);
      } catch (err) {
        assert.instanceOf(err, error.UnexpectedError);
        hasError = true;
      }
      assert.isTrue(hasError);
    });

    it('will rethrow a DataValidationError when the validate method on the model errors', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateWorkspace',
        sandbox.stub().resolves(MOCK_PROJECT.workspace._id)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateMembers',
        sandbox.stub().resolves(MOCK_PROJECT.members)
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validateTags',
        sandbox.stub().resolves(MOCK_PROJECT.tags)
      );

      const objectId = new mongoose.Types.ObjectId();
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'validate',
        sandbox.stub().rejects('oops an error has occurred')
      );
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'create',
        sandbox.stub().resolves([{_id: objectId}])
      );
      const stub = sandbox.stub();
      stub.resolves({_id: objectId});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', stub);
      let hasError = false;
      try {
        await {{pascalcase this.name}}Model.create{{pascalcase this.name}}(MOCK_PROJECT);
      } catch (err) {
        assert.instanceOf(err, error.DataValidationError);
        hasError = true;
      }
      assert.isTrue(hasError);
    });
  });

  context('update{{pascalcase this.name}}ById', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('Should update a {{camelcase this.name}}', async () => {
      const update{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
        workspace: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,
        owner: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IUser,
        state: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IState,
      };

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      const updateStub = sandbox.stub();
      updateStub.resolves({modifiedCount: 1});
      sandbox.replace({{pascalcase this.name}}Model, 'updateOne', updateStub);

      const get{{pascalcase this.name}}Stub = sandbox.stub();
      get{{pascalcase this.name}}Stub.resolves({_id: {{camelcase this.name}}Id});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}Stub);

      const validateStub = sandbox.stub();
      validateStub.resolves(undefined as void);
      sandbox.replace({{pascalcase this.name}}Model, 'validateUpdateObject', validateStub);

      const result = await {{pascalcase this.name}}Model.update{{pascalcase this.name}}ById(
        {{camelcase this.name}}Id,
        update{{pascalcase this.name}}
      );

      assert.strictEqual(result._id, {{camelcase this.name}}Id);
      assert.isTrue(updateStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}Stub.calledOnce);
      assert.isTrue(validateStub.calledOnce);
    });

    it('Should update a {{camelcase this.name}} with refrences as ObjectIds', async () => {
      const update{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
        workspace: new mongoose.Types.ObjectId(),
        template: new mongoose.Types.ObjectId(),
        owner: new mongoose.Types.ObjectId(),
        state: new mongoose.Types.ObjectId(),
        viewName: 'this is my view name',
      } as unknown as databaseTypes.I{{pascalcase this.name}};

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      const updateStub = sandbox.stub();
      updateStub.resolves({modifiedCount: 1});
      sandbox.replace({{pascalcase this.name}}Model, 'updateOne', updateStub);

      const get{{pascalcase this.name}}Stub = sandbox.stub();
      get{{pascalcase this.name}}Stub.resolves({_id: {{camelcase this.name}}Id});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}Stub);

      const validateStub = sandbox.stub();
      validateStub.resolves(undefined as void);
      sandbox.replace({{pascalcase this.name}}Model, 'validateUpdateObject', validateStub);

      const result = await {{pascalcase this.name}}Model.update{{pascalcase this.name}}ById(
        {{camelcase this.name}}Id,
        update{{pascalcase this.name}}
      );

      assert.strictEqual(result._id, {{camelcase this.name}}Id);
      assert.isTrue(updateStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}Stub.calledOnce);
      assert.isTrue(validateStub.calledOnce);
    });
    it('Will fail when the {{camelcase this.name}} does not exist', async () => {
      const update{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
      };

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      const updateStub = sandbox.stub();
      updateStub.resolves({modifiedCount: 0});
      sandbox.replace({{pascalcase this.name}}Model, 'updateOne', updateStub);

      const get{{pascalcase this.name}}Stub = sandbox.stub();
      get{{pascalcase this.name}}Stub.resolves({_id: {{camelcase this.name}}Id});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}Stub);

      let errorred = false;
      try {
        await {{pascalcase this.name}}Model.update{{pascalcase this.name}}ById({{camelcase this.name}}Id, update{{pascalcase this.name}});
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errorred = true;
      }
      assert.isTrue(errorred);
    });

    it('Will fail when validateUpdateObject fails', async () => {
      const update{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
      };

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      const updateStub = sandbox.stub();
      updateStub.resolves({modifiedCount: 1});
      sandbox.replace({{pascalcase this.name}}Model, 'updateOne', updateStub);

      const get{{pascalcase this.name}}Stub = sandbox.stub();
      get{{pascalcase this.name}}Stub.resolves({_id: {{camelcase this.name}}Id});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}Stub);

      const validateStub = sandbox.stub();
      validateStub.rejects(
        new error.InvalidOperationError("You can't do this", {})
      );
      sandbox.replace({{pascalcase this.name}}Model, 'validateUpdateObject', validateStub);
      let errorred = false;
      try {
        await {{pascalcase this.name}}Model.update{{pascalcase this.name}}ById({{camelcase this.name}}Id, update{{pascalcase this.name}});
      } catch (err) {
        assert.instanceOf(err, error.InvalidOperationError);
        errorred = true;
      }
      assert.isTrue(errorred);
    });

    it('Will fail when a database error occurs', async () => {
      const update{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
      };

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      const updateStub = sandbox.stub();
      updateStub.rejects('something terrible has happened');
      sandbox.replace({{pascalcase this.name}}Model, 'updateOne', updateStub);

      const get{{pascalcase this.name}}Stub = sandbox.stub();
      get{{pascalcase this.name}}Stub.resolves({_id: {{camelcase this.name}}Id});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}Stub);

      const validateStub = sandbox.stub();
      validateStub.resolves(undefined as void);
      sandbox.replace({{pascalcase this.name}}Model, 'validateUpdateObject', validateStub);

      let errorred = false;
      try {
        await {{pascalcase this.name}}Model.update{{pascalcase this.name}}ById({{camelcase this.name}}Id, update{{pascalcase this.name}});
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errorred = true;
      }
      assert.isTrue(errorred);
    });
  });

  context('validateUpdateObject', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will not throw an error when no unsafe fields are present', async () => {
      const input{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
      };

      let errored = false;

      try {
        await {{pascalcase this.name}}Model.validateUpdateObject(input{{pascalcase this.name}});
      } catch (err) {
        errored = true;
      }
      assert.isFalse(errored);
    });

    it('will not throw an error when the related fields exist in the database', async () => {
      const input{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
        workspace: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,
        owner: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IUser,
        state: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IState,
      };
      const orgStub = sandbox.stub();
      orgStub.resolves(true);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', orgStub);

      const templateStub = sandbox.stub();
      templateStub.resolves(true);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        templateStub
      );

      let errored = false;

      try {
        await {{pascalcase this.name}}Model.validateUpdateObject(input{{pascalcase this.name}});
      } catch (err) {
        errored = true;
      }
      assert.isFalse(errored);
      assert.isTrue(orgStub.calledOnce);
      assert.isTrue(templateStub.calledOnce);
    });

    it('will fail when the workspace does not exist.', async () => {
      const input{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
        workspace: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,
        owner: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IUser,
        state: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IState,
      };
      const orgStub = sandbox.stub();
      orgStub.resolves(false);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', orgStub);

      const ownerStub = sandbox.stub();
      ownerStub.resolves(true);
      sandbox.replace(UserModel, 'userIdExists', ownerStub);

      const stateStub = sandbox.stub();
      stateStub.resolves(true);
      sandbox.replace(StateModel, 'stateIdExists', stateStub);

      const templateStub = sandbox.stub();
      templateStub.resolves(true);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        templateStub
      );

      let errored = false;

      try {
        await {{pascalcase this.name}}Model.validateUpdateObject(input{{pascalcase this.name}});
      } catch (err) {
        assert.instanceOf(err, error.InvalidOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will fail when trying to update the _id', async () => {
      const input{{pascalcase this.name}} = {
        _id: new mongoose.Types.ObjectId(),
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
        workspace: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,
        owner: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IUser,
        state: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IState,
      };
      const orgStub = sandbox.stub();
      orgStub.resolves(true);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', orgStub);

      const ownerStub = sandbox.stub();
      ownerStub.resolves(true);
      sandbox.replace(UserModel, 'userIdExists', ownerStub);

      const stateStub = sandbox.stub();
      stateStub.resolves(true);
      sandbox.replace(StateModel, 'stateIdExists', stateStub);

      const templateStub = sandbox.stub();
      templateStub.resolves(true);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        templateStub
      );
      let errored = false;

      try {
        await {{pascalcase this.name}}Model.validateUpdateObject(input{{pascalcase this.name}});
      } catch (err) {
        assert.instanceOf(err, error.InvalidOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will fail when trying to update the createdAt', async () => {
      const input{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
        workspace: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,
        owner: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IUser,
        state: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IState,
        createdAt: new Date(),
      };
      const orgStub = sandbox.stub();
      orgStub.resolves(true);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', orgStub);

      const ownerStub = sandbox.stub();
      ownerStub.resolves(true);
      sandbox.replace(UserModel, 'userIdExists', ownerStub);

      const stateStub = sandbox.stub();
      stateStub.resolves(true);
      sandbox.replace(StateModel, 'stateIdExists', stateStub);

      const templateStub = sandbox.stub();
      templateStub.resolves(true);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        templateStub
      );
      let errored = false;

      try {
        await {{pascalcase this.name}}Model.validateUpdateObject(input{{pascalcase this.name}});
      } catch (err) {
        assert.instanceOf(err, error.InvalidOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will fail when trying to update the updatedAt', async () => {
      const input{{pascalcase this.name}} = {
        name: 'Test {{pascalcase this.name}}',
        description: 'This is a test {{camelcase this.name}}',
        workspace: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,
        owner: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IUser,
        state: {
          _id: new mongoose.Types.ObjectId(),
        } as unknown as databaseTypes.IState,
        updatedAt: new Date(),
      };
      const orgStub = sandbox.stub();
      orgStub.resolves(true);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', orgStub);

      const ownerStub = sandbox.stub();
      ownerStub.resolves(true);
      sandbox.replace(UserModel, 'userIdExists', ownerStub);

      const stateStub = sandbox.stub();
      stateStub.resolves(true);
      sandbox.replace(StateModel, 'stateIdExists', stateStub);

      const templateStub = sandbox.stub();
      templateStub.resolves(true);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        templateStub
      );
      let errored = false;

      try {
        await {{pascalcase this.name}}Model.validateUpdateObject(input{{pascalcase this.name}});
      } catch (err) {
        assert.instanceOf(err, error.InvalidOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('Delete a {{camelcase this.name}} document', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('should remove a {{camelcase this.name}}', async () => {
      const deleteStub = sandbox.stub();
      deleteStub.resolves({deletedCount: 1});
      sandbox.replace({{pascalcase this.name}}Model, 'deleteOne', deleteStub);

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      await {{pascalcase this.name}}Model.delete{{pascalcase this.name}}ById({{camelcase this.name}}Id);

      assert.isTrue(deleteStub.calledOnce);
    });

    it('should fail with an InvalidArgumentError when the {{camelcase this.name}} does not exist', async () => {
      const deleteStub = sandbox.stub();
      deleteStub.resolves({deletedCount: 0});
      sandbox.replace({{pascalcase this.name}}Model, 'deleteOne', deleteStub);

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      let errorred = false;
      try {
        await {{pascalcase this.name}}Model.delete{{pascalcase this.name}}ById({{camelcase this.name}}Id);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errorred = true;
      }

      assert.isTrue(errorred);
    });

    it('should fail with an DatabaseOperationError when the underlying database connection throws an error', async () => {
      const deleteStub = sandbox.stub();
      deleteStub.rejects('something bad has happened');
      sandbox.replace({{pascalcase this.name}}Model, 'deleteOne', deleteStub);

      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();

      let errorred = false;
      try {
        await {{pascalcase this.name}}Model.delete{{pascalcase this.name}}ById({{camelcase this.name}}Id);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errorred = true;
      }

      assert.isTrue(errorred);
    });
  });

  context('all{{pascalcase this.name}}IdsExist', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('should return true when all the {{camelcase this.name}} ids exist', async () => {
      const {{camelcase this.name}}Ids = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const returned{{pascalcase this.name}}Ids = {{camelcase this.name}}Ids.map({{camelcase this.name}}Id => {
        return {
          _id: {{camelcase this.name}}Id,
        };
      });

      const findStub = sandbox.stub();
      findStub.resolves(returned{{pascalcase this.name}}Ids);
      sandbox.replace({{pascalcase this.name}}Model, 'find', findStub);

      assert.isTrue(await {{pascalcase this.name}}Model.all{{pascalcase this.name}}IdsExist({{camelcase this.name}}Ids));
      assert.isTrue(findStub.calledOnce);
    });

    it('should throw a DataNotFoundError when one of the ids does not exist', async () => {
      const {{camelcase this.name}}Ids = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const returned{{pascalcase this.name}}Ids = [
        {
          _id: {{camelcase this.name}}Ids[0],
        },
      ];

      const findStub = sandbox.stub();
      findStub.resolves(returned{{pascalcase this.name}}Ids);
      sandbox.replace({{pascalcase this.name}}Model, 'find', findStub);
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.all{{pascalcase this.name}}IdsExist({{camelcase this.name}}Ids);
      } catch (err: any) {
        assert.instanceOf(err, error.DataNotFoundError);
        assert.strictEqual(
          err.data.value[0].toString(),
          {{camelcase this.name}}Ids[1].toString()
        );
        errored = true;
      }
      assert.isTrue(errored);
      assert.isTrue(findStub.calledOnce);
    });

    it('should throw a DatabaseOperationError when the undelying connection errors', async () => {
      const {{camelcase this.name}}Ids = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const findStub = sandbox.stub();
      findStub.rejects('something bad has happened');
      sandbox.replace({{pascalcase this.name}}Model, 'find', findStub);
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.all{{pascalcase this.name}}IdsExist({{camelcase this.name}}Ids);
      } catch (err: any) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
      assert.isTrue(findStub.calledOnce);
    });
  });

  context('get{{pascalcase this.name}}ById', () => {
    class MockMongooseQuery {
      mockData?: any;
      throwError?: boolean;
      constructor(input: any, throwError = false) {
        this.mockData = input;
        this.throwError = throwError;
      }
      populate() {
        return this;
      }

      async lean(): Promise<any> {
        if (this.throwError) throw this.mockData;

        return this.mockData;
      }
    }

    const mock{{pascalcase this.name}}: databaseTypes.I{{pascalcase this.name}} = {
      _id: new mongoose.Types.ObjectId(),
      createdAt: new Date(),
      updatedAt: new Date(),
      name: 'test{{pascalcase this.name}}',
      description: 'this is a test {{camelcase this.name}}',
      sdtPath: 'testsdtpath',
      slug: 'test slug',
      isTemplate: false,
      stateHistory: [
        {
          _id: new mongoose.Types.ObjectId(),
          __v: 1,
          camera: {_id: new mongoose.Types.ObjectId(), __v: 1},
        },
      ] as unknown as databaseTypes.IState,
      members: [],
      files: [],
      __v: 1,
      owner: {
        _id: new mongoose.Types.ObjectId(),
        name: 'test user',
        __v: 1,
      } as unknown as databaseTypes.IUser,
      workspace: {
        _id: new mongoose.Types.ObjectId(),
        name: 'test workspace',
        __v: 1,
      } as unknown as databaseTypes.IWorkspace,
      template: {
        _id: new mongoose.Types.ObjectId(),
        name: 'test workspace',
        __v: 1,
      } as unknown as databaseTypes.I{{pascalcase this.name}}Template,

      state: {
        _id: new mongoose.Types.ObjectId(),
        version: 1,
        __v: 1,
      } as unknown as databaseTypes.IState,
      viewName: 'test View name',
    } as unknown as databaseTypes.I{{pascalcase this.name}};

    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will retreive a {{camelcase this.name}} document with the related fields populated', async () => {
      const findByIdStub = sandbox.stub();
      findByIdStub.returns(new MockMongooseQuery(mock{{pascalcase this.name}}));
      sandbox.replace({{pascalcase this.name}}Model, 'findById', findByIdStub);

      const doc = await {{pascalcase this.name}}Model.get{{pascalcase this.name}}ById(
        mock{{pascalcase this.name}}._id as mongoose.Types.ObjectId
      );

      assert.isTrue(findByIdStub.calledOnce);
      assert.isUndefined((doc as any).__v);
      assert.isUndefined((doc.template as any).__v);
      assert.isUndefined((doc.workspace as any).__v);
      assert.isUndefined((doc.stateHistory[0] as any).__v);
      assert.isUndefined((doc.stateHistory[0].camera as any).__v);

      assert.strictEqual(doc._id, mock{{pascalcase this.name}}._id);
    });

    it('will throw a DataNotFoundError when the {{camelcase this.name}} does not exist', async () => {
      const findByIdStub = sandbox.stub();
      findByIdStub.returns(new MockMongooseQuery(null));
      sandbox.replace({{pascalcase this.name}}Model, 'findById', findByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.get{{pascalcase this.name}}ById(
          mock{{pascalcase this.name}}._id as mongoose.Types.ObjectId
        );
      } catch (err) {
        assert.instanceOf(err, error.DataNotFoundError);
        errored = true;
      }

      assert.isTrue(errored);
    });

    it('will throw a DatabaseOperationError when an underlying database connection throws an error', async () => {
      const findByIdStub = sandbox.stub();
      findByIdStub.returns(
        new MockMongooseQuery('something bad happened', true)
      );
      sandbox.replace({{pascalcase this.name}}Model, 'findById', findByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.get{{pascalcase this.name}}ById(
          mock{{pascalcase this.name}}._id as mongoose.Types.ObjectId
        );
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }

      assert.isTrue(errored);
    });
  });

  context('validateTemplate', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will validate the template', async () => {
      const {{camelcase this.name}}TemplateId = new mongoose.Types.ObjectId();

      const idExistsStub = sandbox.stub();
      idExistsStub.resolves(true);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        idExistsStub
      );

      const result = await {{pascalcase this.name}}Model.validateTemplate({{camelcase this.name}}TemplateId);

      assert.strictEqual(result.toString(), {{camelcase this.name}}TemplateId.toString());
      assert.isTrue(idExistsStub.calledOnce);
    });

    it('will validate the template passing template as an I{{pascalcase this.name}}Template', async () => {
      const {{camelcase this.name}}TemplateId = new mongoose.Types.ObjectId();

      const idExistsStub = sandbox.stub();
      idExistsStub.resolves(true);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        idExistsStub
      );

      const result = await {{pascalcase this.name}}Model.validateTemplate({
        _id: {{camelcase this.name}}TemplateId,
      } as unknown as database.I{{pascalcase this.name}}Template);

      assert.strictEqual(result.toString(), {{camelcase this.name}}TemplateId.toString());
      assert.isTrue(idExistsStub.calledOnce);
    });
    it('will throw an invalidArgumentError when the {{camelcase this.name}}Template does not exist', async () => {
      const {{camelcase this.name}}TemplateId = new mongoose.Types.ObjectId();

      const idExistsStub = sandbox.stub();
      idExistsStub.resolves(false);
      sandbox.replace(
        {{pascalcase this.name}}TemplateModel,
        '{{camelcase this.name}}TemplateIdExists',
        idExistsStub
      );
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateTemplate({{camelcase this.name}}TemplateId);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('validateWorkspace', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will validate the workspace', async () => {
      const workspaceId = new mongoose.Types.ObjectId();

      const idExistsStub = sandbox.stub();
      idExistsStub.resolves(true);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', idExistsStub);

      const result = await {{pascalcase this.name}}Model.validateWorkspace(workspaceId);

      assert.strictEqual(result.toString(), workspaceId.toString());
      assert.isTrue(idExistsStub.calledOnce);
    });

    it('will validate the workspace passing the workspace as an IWorkspace', async () => {
      const workspaceId = new mongoose.Types.ObjectId();

      const idExistsStub = sandbox.stub();
      idExistsStub.resolves(true);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', idExistsStub);

      const result = await {{pascalcase this.name}}Model.validateWorkspace({
        _id: workspaceId,
      } as unknown as databaseTypes.IWorkspace);

      assert.strictEqual(result.toString(), workspaceId.toString());
      assert.isTrue(idExistsStub.calledOnce);
    });

    it('will throw an invalidArgumentError when the workspace does not exist', async () => {
      const workspaceId = new mongoose.Types.ObjectId();

      const idExistsStub = sandbox.stub();
      idExistsStub.resolves(false);
      sandbox.replace(WorkspaceModel, 'workspaceIdExists', idExistsStub);
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateWorkspace(workspaceId);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('query{{pascalcase this.name}}s', () => {
    class MockMongooseQuery {
      mockData?: any;
      throwError?: boolean;
      constructor(input: any, throwError = false) {
        this.mockData = input;
        this.throwError = throwError;
      }

      populate() {
        return this;
      }

      async lean(): Promise<any> {
        if (this.throwError) throw this.mockData;

        return this.mockData;
      }
    }

    const mock{{pascalcase this.name}}s = [
      {
        _id: new mongoose.Types.ObjectId(),
        createdAt: new Date(),
        updatedAt: new Date(),
        name: 'test{{pascalcase this.name}}',
        description: 'this is a test {{camelcase this.name}}',
        sdtPath: 'testsdtpath',
        slug: 'test slug',
        stateHistory: [],
        members: [],
        tags: [],
        files: [],
        __v: 1,
        owner: {
          _id: new mongoose.Types.ObjectId(),
          name: 'test user',
          __v: 1,
        } as unknown as databaseTypes.IUser,
        workspace: {
          _id: new mongoose.Types.ObjectId(),
          name: 'test workspace',
          __v: 1,
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
          name: 'test workspace',
          __v: 1,
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,
        state: {
          _id: new mongoose.Types.ObjectId(),
          version: 1,
          __v: 1,
        } as unknown as databaseTypes.IState,
        viewName: 'test View name',
      } as databaseTypes.I{{pascalcase this.name}},
      {
        _id: new mongoose.Types.ObjectId(),
        createdAt: new Date(),
        updatedAt: new Date(),
        name: 'test{{pascalcase this.name}}2',
        description: 'this is a test {{camelcase this.name}}2',
        sdtPath: 'testsdtpath2',
        stateHistory: [],
        members: [],
        tags: [],
        slug: 'test slug2',

        files: [],
        __v: 1,
        owner: {
          _id: new mongoose.Types.ObjectId(),
          name: 'test user2',
          __v: 1,
        } as unknown as databaseTypes.IUser,
        workspace: {
          _id: new mongoose.Types.ObjectId(),
          name: 'test workspace2',
          __v: 1,
        } as unknown as databaseTypes.IWorkspace,
        template: {
          _id: new mongoose.Types.ObjectId(),
          name: 'test workspace2',
          __v: 1,
        } as unknown as databaseTypes.I{{pascalcase this.name}}Template,

        state: {
          _id: new mongoose.Types.ObjectId(),
          version: 1,
          __v: 1,
        } as unknown as databaseTypes.IState,
        viewName: 'test View name2',
      } as databaseTypes.I{{pascalcase this.name}},
    ];
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will return the filtered {{camelcase this.name}}s', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'count',
        sandbox.stub().resolves(mock{{pascalcase this.name}}s.length)
      );

      sandbox.replace(
        {{pascalcase this.name}}Model,
        'find',
        sandbox.stub().returns(new MockMongooseQuery(mock{{pascalcase this.name}}s))
      );

      const results = await {{pascalcase this.name}}Model.query{{pascalcase this.name}}s({});

      assert.strictEqual(results.numberOfItems, mock{{pascalcase this.name}}s.length);
      assert.strictEqual(results.page, 0);
      assert.strictEqual(results.results.length, mock{{pascalcase this.name}}s.length);
      assert.isNumber(results.itemsPerPage);
      results.results.forEach((doc: any) => {
        assert.isUndefined((doc as any).__v);
        assert.isUndefined((doc.template as any).__v);
        assert.isUndefined((doc.workspace as any).__v);
      });
    });

    it('will throw a DataNotFoundError when no values match the filter', async () => {
      sandbox.replace({{pascalcase this.name}}Model, 'count', sandbox.stub().resolves(0));

      sandbox.replace(
        {{pascalcase this.name}}Model,
        'find',
        sandbox.stub().returns(new MockMongooseQuery(mock{{pascalcase this.name}}s))
      );

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.query{{pascalcase this.name}}s();
      } catch (err) {
        assert.instanceOf(err, error.DataNotFoundError);
        errored = true;
      }

      assert.isTrue(errored);
    });

    it('will throw an InvalidArgumentError when the page number exceeds the number of available pages', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'count',
        sandbox.stub().resolves(mock{{pascalcase this.name}}s.length)
      );

      sandbox.replace(
        {{pascalcase this.name}}Model,
        'find',
        sandbox.stub().returns(new MockMongooseQuery(mock{{pascalcase this.name}}s))
      );

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.query{{pascalcase this.name}}s({}, 1, 10);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errored = true;
      }

      assert.isTrue(errored);
    });

    it('will throw a DatabaseOperationError when the underlying database connection fails', async () => {
      sandbox.replace(
        {{pascalcase this.name}}Model,
        'count',
        sandbox.stub().resolves(mock{{pascalcase this.name}}s.length)
      );

      sandbox.replace(
        {{pascalcase this.name}}Model,
        'find',
        sandbox
          .stub()
          .returns(new MockMongooseQuery('something bad has happened', true))
      );

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.query{{pascalcase this.name}}s({});
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }

      assert.isTrue(errored);
    });
  });

  context('validateTags', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will validate the tags where the ids are objectIds', async () => {
      const tagIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allTagIdsExistStub = sandbox.stub();
      allTagIdsExistStub.resolves();
      sandbox.replace(TagModel, 'allTagIdsExist', allTagIdsExistStub);

      const res = await {{pascalcase this.name}}Model.validateTags(tagIds);
      assert.deepEqual(res, tagIds);
      assert.isTrue(allTagIdsExistStub.calledOnce);
    });

    it('will validate the states where the ids are objects', async () => {
      const tagIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allTagIdsExistStub = sandbox.stub();
      allTagIdsExistStub.resolves();
      sandbox.replace(TagModel, 'allTagIdsExist', allTagIdsExistStub);

      const res = await {{pascalcase this.name}}Model.validateTags(
        tagIds.map(id => ({_id: id} as databaseTypes.ITag))
      );
      assert.deepEqual(res, tagIds);
      assert.isTrue(allTagIdsExistStub.calledOnce);
    });

    it('will wrap a DataNotFoundError in a DataValidationError', async () => {
      const tagIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allTagIdsExistStub = sandbox.stub();
      allTagIdsExistStub.rejects(
        new error.DataNotFoundError(
          'The data does not exist',
          'stateIds',
          tagIds
        )
      );
      sandbox.replace(TagModel, 'allTagIdsExist', allTagIdsExistStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateTags(tagIds);
      } catch (err) {
        assert.instanceOf(err, error.DataValidationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will pass through a DatabaseOperationError', async () => {
      const tagIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allTagIdsExistStub = sandbox.stub();
      allTagIdsExistStub.rejects(
        new error.DatabaseOperationError(
          'Something has gone horribly wrong',
          'mongoDb',
          ' TagModel.allTagIdsExist',
          tagIds
        )
      );
      sandbox.replace(TagModel, 'allTagIdsExist', allTagIdsExistStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateTags(tagIds);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('validateStates', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will validate the states where the ids are objectIds', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allStateIdsExistStub = sandbox.stub();
      allStateIdsExistStub.resolves();
      sandbox.replace(StateModel, 'allStateIdsExist', allStateIdsExistStub);

      const res = await {{pascalcase this.name}}Model.validateStates(stateIds);
      assert.deepEqual(res, stateIds);
      assert.isTrue(allStateIdsExistStub.calledOnce);
    });

    it('will validate the states where the ids are objects', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allStateIdsExistStub = sandbox.stub();
      allStateIdsExistStub.resolves();
      sandbox.replace(StateModel, 'allStateIdsExist', allStateIdsExistStub);

      const res = await {{pascalcase this.name}}Model.validateStates(
        stateIds.map(id => ({_id: id} as databaseTypes.IState))
      );
      assert.deepEqual(res, stateIds);
      assert.isTrue(allStateIdsExistStub.calledOnce);
    });

    it('will wrap a DataNotFoundError in a DataValidationError', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allStateIdsExistStub = sandbox.stub();
      allStateIdsExistStub.rejects(
        new error.DataNotFoundError(
          'The data does not exist',
          'stateIds',
          stateIds
        )
      );
      sandbox.replace(StateModel, 'allStateIdsExist', allStateIdsExistStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateStates(stateIds);
      } catch (err) {
        assert.instanceOf(err, error.DataValidationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will pass through a DatabaseOperationError', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const allStateIdsExistStub = sandbox.stub();
      allStateIdsExistStub.rejects(
        new error.DatabaseOperationError(
          'Something has gone horribly wrong',
          'mongoDb',
          ' StateModel.allStateIdsExist',
          stateIds
        )
      );
      sandbox.replace(StateModel, 'allStateIdsExist', allStateIdsExistStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateStates(stateIds);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('addStates', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will add the states as ObjectIds', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const saveStub = sandbox.stub();
      saveStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: [],
        save: saveStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateStatesStub = sandbox.stub();
      validateStatesStub.resolves(stateIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateStates', validateStatesStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: []});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.addStates({{camelcase this.name}}Id, stateIds);

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(validateStatesStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(saveStub.calledOnce);
    });

    it('will not add the states if they already exist on the {{camelcase this.name}}', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const saveStub = sandbox.stub();
      saveStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: stateIds,
        save: saveStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateStatesStub = sandbox.stub();
      validateStatesStub.resolves(stateIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateStates', validateStatesStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: []});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.addStates({{camelcase this.name}}Id, stateIds);

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(validateStatesStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isFalse(saveStub.called);
    });

    it('will add the states as objects', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const saveStub = sandbox.stub();
      saveStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: [],
        save: saveStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateStatesStub = sandbox.stub();
      validateStatesStub.resolves(stateIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateStates', validateStatesStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: []});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.addStates(
        {{camelcase this.name}}Id,
        stateIds.map(id => ({_id: id} as unknown as databaseTypes.IState))
      );

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(validateStatesStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(saveStub.calledOnce);
    });

    it('will throw an InvalidArgumentError if the input states length === 0', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: [],
        save: () => {},
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateStatesStub = sandbox.stub();
      validateStatesStub.resolves(stateIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateStates', validateStatesStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: []});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addStates({{camelcase this.name}}Id, []);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw an DataNotFoundError if the input {{camelcase this.name}} does not exist', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      find{{pascalcase this.name}}ByIdStub.resolves();
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateStatesStub = sandbox.stub();
      validateStatesStub.resolves(stateIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateStates', validateStatesStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: []});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addStates({{camelcase this.name}}Id, stateIds);
      } catch (err) {
        assert.instanceOf(err, error.DataNotFoundError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw an DataValidationError if the states do not exist', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: [],
        save: () => {},
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateStatesStub = sandbox.stub();
      validateStatesStub.rejects(
        new error.DataValidationError(
          'This data is not valid',
          'states',
          stateIds
        )
      );
      sandbox.replace({{pascalcase this.name}}Model, 'validateStates', validateStatesStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: []});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addStates({{camelcase this.name}}Id, stateIds);
      } catch (err) {
        assert.instanceOf(err, error.DataValidationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw an DatabaseOperationError if the underlying database call fails', async () => {
      const stateIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: [],
        save: () => {
          throw 'what do you think you are trying to do';
        },
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateStatesStub = sandbox.stub();
      validateStatesStub.resolves();
      sandbox.replace({{pascalcase this.name}}Model, 'validateStates', validateStatesStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: []});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);
      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addStates({{camelcase this.name}}Id, stateIds);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('removeMemebers', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will remove a {{camelcase this.name}} member', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const members = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: members,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: members});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.removeMembers({{camelcase this.name}}Id, members);

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(savedStub.calledOnce);
    });

    it('will remove a {{camelcase this.name}} members with ids as object', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const members = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: members,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: members});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.removeMembers(
        {{camelcase this.name}}Id,
        members.map(member => {
          return {_id: member} as unknown as databaseTypes.IMember;
        })
      );

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(savedStub.calledOnce);
    });

    it('will not remove non existing {{camelcase this.name}} member', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const members = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: members,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: members});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.removeMembers({{camelcase this.name}}Id, [
        new mongoose.Types.ObjectId(),
      ]);

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isFalse(savedStub.called);
    });

    it('will throw an InvalidArgumentError when the members argument is empty', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const members = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: members,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: members});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.removeMembers({{camelcase this.name}}Id, []);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will passthrough a DataNotFoundError when the {{camelcase this.name}} does exist ', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const members = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves();
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: members});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.removeMembers({{camelcase this.name}}Id, members);
      } catch (err) {
        assert.instanceOf(err, error.DataNotFoundError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw a databaseOperationError when the underlying Database call fails', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const members = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.rejects('The database has failed');
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: members,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: members});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.removeMembers({{camelcase this.name}}Id, members);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('validateMembers', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will validate members with ids as objectIds', async () => {
      const members = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const allMemberIdsExistStub = sandbox.stub();
      allMemberIdsExistStub.resolves();
      sandbox.replace(MemberModel, 'allMemberIdsExist', allMemberIdsExistStub);

      const res = await {{pascalcase this.name}}Model.validateMembers(members);
      assert.deepEqual(res, members);
      assert.isTrue(allMemberIdsExistStub.calledOnce);
    });

    it('will validate members with ids as objects', async () => {
      const members = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const allMemberIdsExistStub = sandbox.stub();
      allMemberIdsExistStub.resolves();
      sandbox.replace(MemberModel, 'allMemberIdsExist', allMemberIdsExistStub);

      const res = await {{pascalcase this.name}}Model.validateMembers(
        members.map(
          member => ({_id: member} as unknown as databaseTypes.IMember)
        )
      );
      assert.deepEqual(res, members);
      assert.isTrue(allMemberIdsExistStub.calledOnce);
    });

    it('will wrap a DataNotFoundError into a DataValidationError when all the memberIds do not exist', async () => {
      const members = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const allMemberIdsExistStub = sandbox.stub();
      allMemberIdsExistStub.rejects(
        new error.DataNotFoundError(
          'The data was not found',
          'members',
          members
        )
      );
      sandbox.replace(MemberModel, 'allMemberIdsExist', allMemberIdsExistStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateMembers(members);
      } catch (err) {
        assert.instanceOf(err, error.DataValidationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will passthrough any other error passed by allMemberIdsExist', async () => {
      const members = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const allMemberIdsExistStub = sandbox.stub();
      allMemberIdsExistStub.rejects(
        new error.DatabaseOperationError(
          'The database failed',
          'mongoDb',
          'members.allMemberIdsExist',
          members
        )
      );
      sandbox.replace(MemberModel, 'allMemberIdsExist', allMemberIdsExistStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.validateMembers(members);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('addMembers', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will add new members with ids passed as objectIds', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const memberIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: [],
        save: savedStub,
      });

      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateMembersStub = sandbox.stub();
      validateMembersStub.resolves(memberIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateMembers', validateMembersStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: memberIds});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.addMembers({{camelcase this.name}}Id, memberIds);
      assert.isOk(res);
      assert.isObject(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(savedStub.calledOnce);
      assert.isTrue(validateMembersStub.calledOnce);
    });

    it('will add new members with ids passed as objects', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const memberIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: [],
        save: savedStub,
      });

      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateMembersStub = sandbox.stub();
      validateMembersStub.resolves(memberIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateMembers', validateMembersStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: memberIds});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.addMembers(
        {{camelcase this.name}}Id,
        memberIds.map(
          member => ({_id: member} as unknown as databaseTypes.IMember)
        )
      );
      assert.isOk(res);
      assert.isObject(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(savedStub.calledOnce);
      assert.isTrue(validateMembersStub.calledOnce);
    });

    it('will add new members if they already exist on the {{camelcase this.name}}', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const memberIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: memberIds,
        save: savedStub,
      });

      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateMembersStub = sandbox.stub();
      validateMembersStub.resolves(memberIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateMembers', validateMembersStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: memberIds});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.addMembers({{camelcase this.name}}Id, memberIds);
      assert.isOk(res);
      assert.isObject(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isFalse(savedStub.called);
      assert.isTrue(validateMembersStub.calledOnce);
    });

    it('will throw an InvalidArgumentError when members.length === 0', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const memberIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: [],
        save: savedStub,
      });

      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateMembersStub = sandbox.stub();
      validateMembersStub.resolves(memberIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateMembers', validateMembersStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: memberIds});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addMembers({{camelcase this.name}}Id, []);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw a DataNotFoundError when {{camelcase this.name}} does not exist', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const memberIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves();

      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateMembersStub = sandbox.stub();
      validateMembersStub.resolves(memberIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateMembers', validateMembersStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: memberIds});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addMembers({{camelcase this.name}}Id, memberIds);
      } catch (err) {
        assert.instanceOf(err, error.DataNotFoundError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw a DataValidationError when members cannot be validated', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const memberIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: [],
        save: savedStub,
      });

      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateMembersStub = sandbox.stub();
      validateMembersStub.rejects(
        new error.DataValidationError(
          'The memberIDs are not valid',
          'members',
          memberIds
        )
      );
      sandbox.replace({{pascalcase this.name}}Model, 'validateMembers', validateMembersStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: memberIds});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addMembers({{camelcase this.name}}Id, memberIds);
      } catch (err) {
        assert.instanceOf(err, error.DataValidationError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw a DatabaseOperationError when the underlying database call fails', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const memberIds = [
        new mongoose.Types.ObjectId(),
        new mongoose.Types.ObjectId(),
      ];

      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.rejects('something really bad has happened');
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        members: [],
        save: savedStub,
      });

      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const validateMembersStub = sandbox.stub();
      validateMembersStub.resolves(memberIds);
      sandbox.replace({{pascalcase this.name}}Model, 'validateMembers', validateMembersStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, members: memberIds});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.addMembers({{camelcase this.name}}Id, memberIds);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });

  context('removeStates', () => {
    const sandbox = createSandbox();

    afterEach(() => {
      sandbox.restore();
    });

    it('will remove a {{camelcase this.name}} state', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const states = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: states,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: states});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.removeStates({{camelcase this.name}}Id, states);

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(savedStub.calledOnce);
    });

    it('will remove a {{camelcase this.name}} states with ids as object', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const states = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: states,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: states});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.removeStates(
        {{camelcase this.name}}Id,
        states.map(member => {
          return {_id: member} as unknown as databaseTypes.IState;
        })
      );

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(savedStub.calledOnce);
    });

    it('will not remove non existing {{camelcase this.name}} state', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const states = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: states,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: states});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      const res = await {{pascalcase this.name}}Model.removeStates({{camelcase this.name}}Id, [
        new mongoose.Types.ObjectId(),
      ]);

      assert.isOk(res);
      assert.isTrue(find{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isTrue(get{{pascalcase this.name}}ByIdStub.calledOnce);
      assert.isFalse(savedStub.called);
    });

    it('will throw an InvalidArgumentError when the state argument is empty', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const states = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: states,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: states});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.removeStates({{camelcase this.name}}Id, []);
      } catch (err) {
        assert.instanceOf(err, error.InvalidArgumentError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will passthrough a DataNotFoundError when the {{camelcase this.name}} does exist ', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const states = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.resolves();
      find{{pascalcase this.name}}ByIdStub.resolves();
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: states});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.removeStates({{camelcase this.name}}Id, states);
      } catch (err) {
        assert.instanceOf(err, error.DataNotFoundError);
        errored = true;
      }
      assert.isTrue(errored);
    });

    it('will throw a databaseOperationError when the underlying Database call fails', async () => {
      const {{camelcase this.name}}Id = new mongoose.Types.ObjectId();
      const states = [new mongoose.Types.ObjectId()];
      const find{{pascalcase this.name}}ByIdStub = sandbox.stub();
      const savedStub = sandbox.stub();
      savedStub.rejects('The database has failed');
      find{{pascalcase this.name}}ByIdStub.resolves({
        _id: {{camelcase this.name}}Id,
        stateHistory: states,
        save: savedStub,
      });
      sandbox.replace({{pascalcase this.name}}Model, 'findById', find{{pascalcase this.name}}ByIdStub);

      const get{{pascalcase this.name}}ByIdStub = sandbox.stub();
      get{{pascalcase this.name}}ByIdStub.resolves({_id: {{camelcase this.name}}Id, stateHistory: states});
      sandbox.replace({{pascalcase this.name}}Model, 'get{{pascalcase this.name}}ById', get{{pascalcase this.name}}ByIdStub);

      let errored = false;
      try {
        await {{pascalcase this.name}}Model.removeStates({{camelcase this.name}}Id, states);
      } catch (err) {
        assert.instanceOf(err, error.DatabaseOperationError);
        errored = true;
      }
      assert.isTrue(errored);
    });
  });
});
